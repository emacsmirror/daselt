;;; daselt-ext.del --- Not required to start daselt-mode, but bound to keys etc.  -*- lexical-binding: t; -*-

;; Copyright (C) 2025  Alexander Prähauser

;; Author: Alexander Prähauser <ahprae@protonmail.com>
;; Package-Requires: ((emacs "29.1"))
;; Version: 1.0
;; Keywords: tools
;; URL: https://gitlab.com/nameiwillforget/d-emacs/daselt-mode/
;; Keywords: tools

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; daselt functions bound to keys and adjecent stuff.

;;; Code:

;;;; Preamble
(require 'cl-lib)
(require 'checkdoc)
(require 'outline)

(declare-function tempo-expand-if-complete "tempo.el")

;; This is only called if daselt-abbrev-chain is t
(declare-function abbrev-chain-with-syntax-table-and-combining-categories nil)
(defvar daselt-cdlatex)
(defvar daselt-yasnippet)
(defvar cdlatex-command-alist-comb)
(defvar daselt-special-read-answer-bindlist)
(defvar daselt-base-definition-types-list)


;;;; Constants
(defconst daselt-backward-command-list
  (remq nil `(sp-kill-hybrid-sexp sp-mark-sexp mark-sexp mark-defun transpose-paragraphs kill-paragraph transpose-sentences delete-char transpose-lines transpose-words transpose-sexps sp-down-sexp down-list transpose-chars other-frame sp-transpose-sexp sp-transpose-hybrid-sexp mark-line daselt-kill-defun delete-all-space delete-horizontal-space sp-up-sexp up-list pdf-view-rotate))
  "List of commands for which backward analogs are created.")

(defconst daselt-new-buffer-command-list
  '(Info-prev Info-next)
  "List of commands for which analogs are created that open a new buffer.")

(defconst daselt-subsentence-command-list
  (remq nil `(backward-sentence forward-sentence backward-kill-sentence kill-sentence ,(if (package-installed-p 'expand-region) 'er/mark-sentence) daselt-backward-transpose-sentences))
  "List of commands for which subsentence analogs are created in.")

;;;; Customs
(defcustom daselt-mode-tab-bar-status-functions
  '(tab-new tab-bar-new-tab)
  "Functions around which `daselt-mode-keep-tab-bar-status' should be wrapped.

Only used if `daselt-mode-keep-tab-bar-status' is t."
  :type 'boolean
  :group 'daselt-mode)

(defcustom daselt-C-4-0-2-contexts-list
  '((minibuffer-mode . minibuffer-complete-and-exit)
    (special-mode . daselt-follow-in-other-window)
    (LaTeX-mode . (lambda () (latex/forward-environment 1)))
    (vterm-mode . vterm-send-tab)
    (emacs-lisp-mode . sp-next-sexp)
    (org-mode . (lambda () (let ((buffer (buffer-name)))
                        (cond ((org-footnote-at-reference-p)
                               org-footnote-action)

                              ((org-at-item-p)
                               (unless (run-hook-with-args-until-success 'org-open-at-point-functions)
                                 (let* ((context
	                                 ;; Only consider supported types, even if they are not the
	                                 ;; closest one.
	                                 (org-element-lineage
	                                  (org-element-context)
	                                  '(citation citation-reference clock comment comment-block
                                                     footnote-definition footnote-reference headline
                                                     inline-src-block inlinetask keyword link node-property
                                                     planning src-block timestamp)
	                                  t))
	                                (type (org-element-type context))
	                                (value (org-element-property :value context)))
                                   (if type
                                       org-open-at-point
                                     org-next-item))))

                              (t (org-open-at-point-global))))))
    (gnus-article-mode . #'gnus-article-show-summary))
  "A list defining actions for `daselt-C-4-0-2' across different modes."
  :type '(repeat (cons symbol sexp))
  :group 'daselt-mode)

(defcustom daselt-C-1-0-2-contexts-list
  '((rectangle-mark-mode . (lambda () (rectangle-forward-char 1)))
    (minibuffer-mode . daselt-move-right-or-exit)
    (image-mode . (lambda () (image-forward-hscroll 1)))
    (pdf-view-mode . (lambda () (image-forward-hscroll 1)))
    (vterm-mode . vterm-send-right))
  "Actions for `daselt-C-1-0-2' in different modes."
  :type '(repeat (cons symbol sexp))
  :group 'daselt-mode)

(defcustom daselt-C-1-0--2-contexts-list
  '((rectangle-mark-mode . (lambda () (rectangle-backward-char 1)))
    (image-mode . (lambda () (image-backward-hscroll 1)))
    (pdf-view-mode . (lambda () (image-backward-hscroll 1)))
    (vterm-mode . vterm-send-left))
  "Actions for `daselt-C-1-0--2' in different modes."
  :type '(repeat (cons symbol sexp))
  :group 'daselt-mode)

(defcustom daselt-C-1-0--3-contexts-list
  '((vterm-copy-mode . previous-line)
    (vterm-mode . vterm-send-up)
    (minibuffer-mode . previous-line-or-history-element)
    (rectangle-mark-mode . (lambda () (rectangle-previous-line 1)))
    (pdf-view-mode . (lambda () (pdf-view-previous-line-or-previous-page 1)))
    (image-mode . image-previous-line)
    (eshell-hist-mode . eshell-previous-input))
  "Actions for `daselt-C-1-0--3' across different modes."
  :type '(repeat (cons symbol sexp))
  :group 'daselt-mode)

(defcustom daselt-C-1-0-3-contexts-list
  '((vterm-copy-mode . next-line)
    (vterm-mode . vterm-send-down)
    (minibuffer-mode . next-line-or-history-element)
    (rectangle-mark-mode . (lambda () rectangle-next-line 1))
    (pdf-view-mode . (lambda () (pdf-view-scroll-up-or-next-page 1)))
    (image-mode . image-next-line)
    (eshell-hist-mode . eshell-next-input))
  "Actions for `daselt-C-1-0-3' across different modes."
  :type '(repeat (cons symbol sexp))
  :group 'daselt-mode)

(defcustom daselt-C-1-0--4-contexts-list
  '((pdf-view-mode . pdf-view-previous-page-command)
    (minibuffer-mode . previous-line-or-history-element)
    (image-mode . image-previous-frame)
    (vterm-copy-mode . scroll-down-command)
    (vterm-mode . vterm-send-prior))
  "Actions for `daselt-C-1-0--1' across different modes."
  :type '(repeat (cons symbol sexp))
  :group 'daselt-mode)

(defcustom daselt-C-1-0-4-contexts-list
  '((pdf-view-mode . pdf-view-next-page-command)
    (minibuffer-mode . next-line-or-history-element)
    (image-mode . image-next-frame)
    (vterm-copy-mode . scroll-up-command)
    (vterm-mode . vterm-send-next))
  "Actions for `daselt-C-1-0-1' across different modes."
  :type '(repeat (cons symbol sexp))
  :group 'daselt-mode)




;;;; Functions
;;;;; Functions for key commands
(defun daselt--funcall-first-mode-match (alist &optional default)
  "Invoke the function associated with the first active mode in ALIST.

Can be a major or minor mode.

If no match is found, DEFAULT is called instead."
  (let ((cmd (cl-loop for mcons in alist
                      for mmode = (car mcons)
                      for mcmd = (cdr mcons)
                      do (if (or (and (boundp mmode)
                                      (memq mmode minor-mode-alist)
                                      (symbol-value mmode))
                                 (derived-mode-p mmode))
                             (cl-return mcmd))
                      finally return default)))
    (funcall-interactively cmd)))

;;;;; Advice functions
;;;;;; Read functions
(defun daselt--translate-read-multiple-choice (fun prompt choices &optional help-string show-help long-form original)
  "Unless ORIGINAL is t, replace short-choices in read-multiple-choice-input.

Replacemets are specified in `daselt-special-read-answer-bindlist'. To be
wrapped around `read-multiple-choice'."
  (if original
      (funcall fun prompt choices help-string show-help long-form)
    (let* ((keylst (mapcar (lambda (bind)
                             (cons (cdr bind)
                                   (string-to-char
                                    (daselt-bind-string bind))))
                           daselt-special-read-answer-bindlist))

           (newchoices (mapcar (lambda (choice) ; We translate forward…
                                 (let* ((choicekey (car choice))

                                        (newkey (alist-get choicekey keylst choicekey))
                                        (newchoice (cons newkey
                                                         (cdr choice))))
                                   newchoice))
                               choices))

           (choicereturn (funcall fun prompt newchoices help-string show-help long-form))

           (carret (car choicereturn)) ; And back.
           (transcarret (daselt-base-reverse-alist-get
                         carret keylst carret))
           (transret (cons transcarret (cdr choicereturn))))
      transret)))

(defun daselt--translate-read-answer (fun question answers)
  "Replace short answers in `read-answer'-input with Daselt values.

These are specified in `daselt-special-read-answer-bindlist'. Wraps around
`read-answer'."
  (let ((newans (mapcar (lambda (answer)
                          (let* ((keylst (mapcar (lambda (bind)
                                                   (cons (cdr bind)
                                                         (string-to-char
                                                          (daselt-bind-string bind))))
                                                 daselt-special-read-answer-bindlist))
                                 (repl (alist-get (cadr answer) keylst))
                                 (ansargs (list (car answer)
                                                (if repl repl (cadr answer))
                                                (caddr answer))))
                            ansargs))
                        answers)))
    (funcall fun question newans)))

(defun daselt--translate-read-char-choice (fun prompt chars &optional inhibit-keyboard-quit)
  "Replace characters in `read-char-choice' with Daselt values.

These are specified in `daselt-special-read-answer-bindlist'. Wraps around
`read-char-choice'."
  (let* ((keylst (mapcar (lambda (bind)
                           (cons (cdr bind)
                                 (string-to-char
                                  (daselt-bind-string bind))))
                         daselt-special-read-answer-bindlist))
         (trans (mapcar (lambda (char)
                          (let ((ret (alist-get char keylst char nil #'=)))
                            ret))
                        chars))
         (answer (funcall fun prompt trans inhibit-keyboard-quit))
         (retrans (daselt-base-reverse-alist-get answer keylst answer #'=)))
    retrans))

;;;;;; rx-functions
(defun daselt-mode-read-rx (fun rx &rest args)
  "Read an rx-form RX and pass forward the generated regexp.

To be wrapped around rxgexp-search and replace forms FUN.

Theoretically, you can put in any lisp-form that evaluates to a regexp, but the
default is `rx'."
  (interactive (read-from-minibuffer "Enter rx: "
                                     '("(rx )" . 5)
                                     nil t))
  (apply fun (eval rx) args))
;;;;; Drawing
(defun daselt-keymap-to-cons-list (keymap)
  "Convert the KEYMAP of key bindings into a list of conses.

Each cons cell has a string (converted for `kbd`) as its car and the binding
value as its cdr."
  (let (result)
    (map-keymap
     (lambda (key binding)
       (when binding
         (let ((key-string (if (vectorp key)
                               (key-description key)
                             (format "%s" key))))
           (push (cons key-string binding) result))))
     keymap)
    (reverse result)))

;;;;; Replace hardcoded keybinds
(defun daselt-checkdoc-interactive-loop (start-here showstatus findfunc)
  "`checkdoc-interactive-loop` customized to include Daselt shortcuts.

See the primary command for documentation."
  ;; Determine where to start the test
  (let* ((begin (prog1 (point)
		  (if (not start-here) (goto-char (point-min)))))
	 ;; Assign a flag to spellcheck flag
	 (checkdoc-spellcheck-documentation-flag
	  (car (memq checkdoc-spellcheck-documentation-flag
                     '(buffer interactive t))))
	 ;; Fetch the error list
	 (err-list (list (funcall findfunc nil)))
	 (cdo nil)
	 (returnme nil)
	 c
         (nextchar (string-to-char (daselt-coords-binding '(1 0 3))))
         (prevchar (string-to-char (daselt-coords-binding '(1 0 -3))))
         (quitchar (string-to-char (daselt-coords-binding '(1 1 -2))))
         (fixchar (string-to-char (daselt-coords-binding '(1 0 2))))
         (inschar (string-to-char (daselt-coords-binding '(1 0 -2)))))
    (save-window-excursion
      (if (not (car err-list)) (setq err-list nil))
      ;; Include whatever function point is in for good measure.
      (beginning-of-defun)
      (while err-list
	(goto-char (cdr (car err-list)))
	;; The cursor should be just in front of the offending doc string
	(setq cdo (if (stringp (car (car err-list)))
	              (save-excursion (make-overlay
				       (point) (progn (forward-sexp 1)
						      (point))))
                    (make-overlay
		     (checkdoc-error-start (car (car err-list)))
		     (checkdoc-error-end (car (car err-list))))))
	(unwind-protect
	    (progn
	      (overlay-put cdo 'face 'highlight)
	      ;; Make sure the whole doc string is visible if possible.
	      (sit-for 0)
	      (if (and (= (following-char) ?\")
		       (not (pos-visible-in-window-p
			     (save-excursion (forward-sexp 1) (point))
			     (selected-window))))
		  (let ((l (count-lines (point)
					(save-excursion
					  (forward-sexp 1) (point)))))
		    (if (> l (window-height))
			(recenter 1)
		      (recenter (/ (- (window-height) l) 2))))
		(recenter))
	      (message "%s (C-h,%s%s)" (checkdoc-error-text
                                        (car (car err-list)))
		       (if (checkdoc-error-unfixable (car (car err-list)))
			   "" (concat (char-to-string fixchar) ","))
                       (mapconcat #'char-to-string
                                  (list nextchar prevchar quitchar inschar)
                                  ","))
	      (save-excursion
		(goto-char (checkdoc-error-start (car (car err-list))))
		(if (not (pos-visible-in-window-p))
		    (recenter (- (window-height) 2)))
		(setq c (read-event)))
	      (if (not (integerp c)) (setq c ??))
	      (cond
	       ;; Exit condition
	       ((eq c ?\C-g) (signal 'quit nil))
	       ;; Request an auto-fix
	       ((eq c fixchar)
		(delete-overlay cdo)
		(setq cdo nil)
		(goto-char (cdr (car err-list)))
		;; `automatic-then-never' tells the autofix function
		;; to only allow one fix to be automatic.  The autofix
		;; function will then set the flag to `never', allowing
		;; the checker to return a different error.
		(let ((checkdoc-autofix-flag 'automatic-then-never)
		      (fixed nil))
		  (funcall findfunc t)
		  (setq fixed (not (eq checkdoc-autofix-flag
				       'automatic-then-never)))
		  (if (not fixed)
		      (progn
			(message "A Fix was not available.")
			(sit-for 2))
		    (setq err-list (cdr err-list))))
		(beginning-of-defun)
		(let ((ne (funcall findfunc nil)))
		  (if ne
		      (setq err-list (cons ne err-list))
		    (cond ((not err-list)
			   (message "No More Stylistic Errors.")
			   (sit-for 2))
			  (t
			   (message
			    "No Additional style errors.  Continuing...")
			   (sit-for 2))))))
	       ;; Move to the next error (if available)
	       ((eq c nextchar)
		(let ((ne (funcall findfunc nil)))
		  (if (not ne)
		      (if showstatus
			  (setq returnme err-list
				err-list nil)
			(if (not err-list)
			    (message "No More Stylistic Errors.")
			  (message "No Additional style errors.  Continuing..."))
			(sit-for 2))
		    (setq err-list (cons ne err-list)))))
	       ;; Go backwards in the list of errors
	       ((eq c prevchar)
		(if (/= (length err-list) 1)
		    (progn
		      (setq err-list (cdr err-list))
		      (goto-char (cdr (car err-list)))
		      (beginning-of-defun))
		  (message "No Previous Errors.")
		  (sit-for 2)))
	       ;; Edit the buffer recursively.
	       ((eq c inschar)
		(checkdoc-recursive-edit
		 (checkdoc-error-text (car (car err-list))))
		(delete-overlay cdo)
		(setq err-list (cdr err-list)) ;back up the error found.
		(beginning-of-defun)
		(let ((ne (funcall findfunc nil)))
		  (if (not ne)
		      (if showstatus
			  (setq returnme err-list
				err-list nil)
			(message "No More Stylistic Errors.")
			(sit-for 2))
		    (setq err-list (cons ne err-list)))))
	       ;; Quit checkdoc
	       ((eq c quitchar)
		(setq returnme err-list
		      err-list nil
		      begin (point)))
	       ;; Goofy stuff
	       (t
                (if (get-buffer-window checkdoc--help-buffer)
		    (progn
                      (delete-window (get-buffer-window checkdoc--help-buffer))
                      (kill-buffer checkdoc--help-buffer))
                  (with-output-to-temp-buffer checkdoc--help-buffer
                    (with-current-buffer standard-output
                      (insert
                       "Checkdoc Keyboard Summary:\n"
                       (if (checkdoc-error-unfixable (car (car err-list)))
                           ""
                         (concat
                          (format "%s    - auto Fix this warning without asking" fixchar)
                          " (if available.)\n"
                          "         Very complex operations will still query.\n"))
                       (format "%s      - Enter recursive Edit.  Press C-M-c to exit.\n" inschar)
                       (format "%s - skip to the Next error.\n" nextchar)
                       (format "%s - skip to the Previous error.\n" prevchar)
                       (format "%s      - Quit checkdoc.\n" quitchar)
                       "C-h    - Toggle this help buffer.")))
		  (shrink-window-if-larger-than-buffer
                   (get-buffer-window checkdoc--help-buffer))))))
	  (if cdo (delete-overlay cdo)))))
    (goto-char begin)
    (if (get-buffer checkdoc--help-buffer) (kill-buffer checkdoc--help-buffer))
    (message "Checkdoc: Done.")
    returnme))

;;;;; Functions for bound commands
;;;;; Replacements
(defun daselt-replace-list-throughout-directory (lst dir fun &optional filetest dirtest allfiles)
  "Replace occurrences of strings or symbols in files throughout a directory.

This function takes a list `lst' of strings or symbols, and for each element, it
replaces occurrences of the corresponding string in the files found in the
specified directory `dir'. The replacement is performed using the provided
function `fun' to determine the replacement string for non-string elements. The
function can also utilize optional predicates for filtering files and
directories.

Parameters:

- LST: A list of strings or symbols. If an element is a cons cell (pair), the
  car is treated as a string to be replaced, and the cdr will be used as the
  replacement directly. For symbols, they are first converted to strings.

- DIR: The directory in which to perform the replacements.

- FUN: A function that takes an element from `lst' and returns the replacement
  string if the element is not a cons cell.

- FILETEST (optional): A predicate function to determine if a file should be
  processed. Should return non-nil for files that match the criteria.

- DIRTEST (optional): A predicate function to determine if a directory should be
  processed. Should return non-nil for directories that match the criteria.

- ALLFILES (optional): If non-nil, indicates that hidden files should also be
  included.

 Returns: A list of the replacement strings corresponding to each element in
 `lst'."
  (cl-flet ((obj-or-name (obj) (if (symbolp obj)
                                   (symbol-name obj)
                                 obj)))
    (mapcar (lambda (obj)
              (let* ((ocnsp (consp obj))
                     (str (if ocnsp (obj-or-name (car obj))
                            (obj-or-name obj)))
                     (repl (if ocnsp
                               (cdr obj)
                             (funcall fun obj))))
                (daselt-replace-string-throughout-directory str repl dir filetest dirtest allfiles)

                repl))
            lst)))

;;;;; Tab-bar
(defun daselt-mode-keep-tab-bar-status (command &optional _dummy)
  "Preserve the tab-bar status while executing COMMAND.

If `tab-bar-mode' is off, it remains off after executing COMMAND."
  (let ((status (if tab-bar-mode 1 0)))
    (progn (tab-bar-mode 1)
           (call-interactively command)
           (tab-bar-mode status))))

;;;;; Commands
;;;;;; Modifiers
(defun daselt-MetaSuper-next-cmd ()
  "Apply Meta and Super modifiers to the next event."
  (interactive)
  (execute-kbd-macro
   (vector
    (event-apply-modifier
     (event-apply-modifier
      (read-event) 'super 23 "s-")
     'meta 27 "M-"))))

;;;;;; General purpose
(defun daselt-rename-file-and-buffer (new-name)
  "Rename the current buffer and its visiting file to NEW-NAME.

Displays a message if the buffer isn't visiting a file or if another buffer with
NEW-NAME already exists."
  (interactive "sNew name: ")
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not filename)
        (message "Buffer '%s' is not visiting a file!" name)
      (if (get-buffer new-name)
          (message "A buffer named '%s' already exists!" new-name)
        (progn
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil))))))

(defun daselt-set-test-fun ()
  "Evaluate the current defun and define `daselt-test' as an alias to it."
  (interactive)
  (let ((fun (call-interactively #'eval-defun)))
    (defalias 'daselt-test fun)))

;;;;;; Navigation
(defun daselt-scroll-chunk-up ()
  "Scroll up by a fixed chunk."
  (interactive)
  (scroll-up-command 10))

(defun daselt-scroll-chunk-down ()
  "Scroll down by a fixed chunk."
  (interactive)
  (scroll-down-command 10))

(defun daselt-outline-forward-up-heading (arg &optional invisible-ok)
  "Move forward to a visible heading on a higher level than the current one.

Move up ARG levels; if INVISIBLE-OK is non-nil, consider invisible lines."
  (interactive "p")
  (and (eq this-command 'outline-up-heading)
       (or (eq last-command 'outline-up-heading) (push-mark)))
  (outline-back-to-heading invisible-ok)
  (let ((start-level (funcall outline-level)))
    (when (<= start-level 1)
      (error "Already at top level of the outline"))
    (while (and (> start-level 1) (> arg 0) (not (bobp)))
      (let ((level start-level))
        (while (not (or (< level start-level) (bobp)))
	  (if invisible-ok
	      (outline-next-heading)
	    (outline-next-visible-heading 1))
	  (setq level (funcall outline-level)))
        (setq start-level level))
      (setq arg (- arg 1))))
  (if outline-search-function
      (funcall outline-search-function nil nil t t)
    (looking-at outline-regexp)))

(defun daselt-switch-to-messages ()
      "Switch to messages buffer."
      (declare (ftype (function nil t)))
      (interactive)
      (switch-to-buffer "*Messages*"))

(defun daselt-follow-in-other-window ()
  "Follow or open link at point in another window."
  (interactive)
  (let ((new-buffer (clone-buffer))
        (current-point (point)))
    ;; (unless (one-window-p)
    ;;   (other-window 1))
    (switch-to-buffer-other-window new-buffer)
    (goto-char current-point)
    (avy-act--follow-or-open)))

;;;;;; Context-Specific behavior
(defun daselt-C-1-0-2 ()
      "Contextual command on `C-(1 0 2)'.

Mode-specific contexts can be edited by changing `daselt-C-1-0-2-contexts-list`.
Default behavior is to move cursor one character forward."
      (interactive)
      (daselt--funcall-first-mode-match daselt-C-1-0-2-contexts-list #'forward-char))

(defun daselt-C-1--1-0 ()
  "Like `back-button-local-backward but interacts better with `daselt-C-4-0-2'."
  (declare (ftype (function nil t)))
  (interactive)
  (cl-letf (((symbol-function 'back-button-push-mark)
             (lambda ()
               (if (eq last-command #'daselt-C-4-0-2)
                   (set-marker (mark-marker) (point) (current-buffer))
                 (push-mark)))))
    (back-button-local-backward)))

(defun daselt-C-1-0--2 ()
  "Contextual command on `C-(1 0 -2)'.

Mode-specific contexts can be edited by changing
`daselt-C-1-0--2-contexts-list`. Default behavior is to move cursor one
character backward."
  (interactive)
  (daselt--funcall-first-mode-match daselt-C-1-0--2-contexts-list #'backward-char))

(defun daselt-C-1-0--3 ()
  "Contextual command on `C-(1 0 -3)'.

Mode-specific contexts can be edited by changing
`daselt-C-1-0--3-contexts-list'. Default behavior is to move cursor one line
up."
  (interactive)
  (daselt--funcall-first-mode-match daselt-C-1-0--3-contexts-list #'previous-line))

(defun daselt-C-1-0-3 ()
  "Contextual command on `C-(1 0 3)'.

Mode-specific contexts can be edited by changing `daselt-C-1-0-3-contexts-list`.
Default behavior is to move cursor line down."
  (interactive)
  (daselt--funcall-first-mode-match daselt-C-1-0-3-contexts-list #'next-line))

(defun daselt-C-1-0--4 ()
  "Contextual command on `C-(1 0 -4)'.

Mode-specific contexts can be edited by changing
`daselt-C-1-0--4-contexts-list`. Default behavior is to move one page up."
  (interactive)
  (daselt--funcall-first-mode-match daselt-C-1-0--4-contexts-list #'scroll-down-command))

(defun daselt-C-1-0-4 ()
  "Contextual command on `C-(1 0 4)'.

Mode-specific contexts can be edited by changing
`daselt-mode-C-1-0-1-contexts-list`. Default behavior is to move one page down."
  (interactive)
  (daselt--funcall-first-mode-match daselt-C-1-0-4-contexts-list #'scroll-up-command))

(cl-defun daselt-C-4-0-2 ()
  "Expand Yasnippet, Cdlatex item, tempo tag, abbrev, Corfu expansion if available.

Also, go to the next item or environment, open a footnote, or open something as
needed.

If point changes position, add the previous position to the `mark-ring'.
This is helpful for when you tried to expand something and it didn't work
for some reason.

In math-mode, no abbrevs are expanded."
  (interactive)

  ;; If we're using `daselt-C-4-0-2-mixed-abbrevs', then we should
  ;; calculate a syntax-table in which the symbols we're using are characters.
  ;; We only need to calculate that table once per buffer, saving CPU cycles.

  (cl-flet ((yas-maybe-expand ()
              (when (yas-maybe-expand-abbrev-key-filter t)
                (yas-expand)
                (cl-return-from daselt-C-4-0-2)))

            (cdlatex-maybe-expand ()
              (let ((pos (point)) expr math-mode)
                (backward-word 1)
                (while (eq (following-char) ?$) (forward-char 1))
                (setq expr (buffer-substring-no-properties (point) pos))
                (setq expr (assoc expr cdlatex-command-alist-comb))
                (if expr (progn (setq math-mode (cdlatex--texmathp))
                                (when (or (and (not math-mode) (nth 5 expr))
                                          (and math-mode (nth 6 expr)))
                                  (delete-char (- pos (point)))
                                  (insert (nth 2 expr))
                                  (and (nth 3 expr)
                                       (if (nth 4 expr)
                                           (apply (nth 3 expr) (nth 4 expr))
                                         (funcall (nth 3 expr)))))
                                (cl-return-from daselt-C-4-0-2))
                  (goto-char pos))))

            (maybe-expand-abbrev ()
              (if (if daselt-abbrev-chain
                      (abbrev-chain-expand)
                    (expand-abbrev))
                  (cl-return-from daselt-C-4-0-2))))

    (when daselt-yasnippet (yas-maybe-expand))
    (when (and daselt-cdlatex cdlatex-mode)
      (cdlatex-maybe-expand))

    (when (and (fboundp #'tempo-expand-if-complete)
               (tempo-expand-if-complete))
      (cl-return-from daselt-C-4-0-2))

    (unless (and (derived-mode-p LaTeX-mode)
                 (or (texmathp))
                 (save-excursion
                   (if daselt-abbrev-chain
                       (abbrev-chain-with-syntax-table-and-combining-categories
                        (backward-word))
                     (backward-word))
                   (texmathp)))
      (maybe-expand-abbrev))

    (let ((pos (point))
          (buf (current-buffer))
          (marker (point-marker)))

      (daselt--funcall-first-mode-match daselt-C-4-0-2-contexts-list #'org-open-at-point-global)

      ;; If point has moved, save the previous position to the mark ring
      (unless (and (eq buf (current-buffer))
                   (= pos (point)))
        (when (mark t)
          (let ((old (nth mark-ring-max mark-ring))
                (history-delete-duplicates nil))
            (add-to-history 'mark-ring marker mark-ring-max t)
            (when old
              (set-marker old nil))))
        ;; (set-marker (mark-marker) pos (current-buffer))

        ;; Don't push the mark on the global mark ring if the last global
        ;; mark pushed was in this same buffer.
        (unless (and global-mark-ring
                     (eq (marker-buffer (car global-mark-ring)) (current-buffer)))
          (let ((old (nth global-mark-ring-max global-mark-ring))
                (history-delete-duplicates nil))
            (add-to-history
             'global-mark-ring (copy-marker (mark-marker)) global-mark-ring-max t)
            (when old
              (set-marker old nil))))))))

;;;;;; Minibuffer
(defun daselt-move-right-or-exit ()
  "Exit if at the end of the minibuffer, otherwise move char right."
  (interactive)
  (if (eobp)
                                                                                                  (exit-minibuffer)
                                                  (forward-char)))

;;;;;; Saving
(defun daselt-abbrev-save ()
  "Save user-defined abbrevs to default abbrev-file."
  (declare (ftype (function () t)))
  (interactive)
  (write-abbrev-file nil))
;;;;;; Yanking
(defun daselt-yank-or-org-roam-node-insert ()
  "Yank text when mark is inactive; otherwise call `org-roam-node-insert`."
  (interactive)
  (cond ((derived-mode-p 'vterm-mode)
         (vterm-yank))
        ((use-region-p)
         (call-interactively #'org-roam-node-insert))
        (t (yank))))

(defun daselt-kill-append ()
  "Kill the currently marked region and append it to the last kill."
  (interactive)
  (append-next-kill)
  (kill-region (mark) (point)))

(defun daselt-copy-append ()
  "Copy the currently marked region and append it to the last kill."
  (interactive)
  (append-next-kill)
  (kill-ring-save (mark) (point)))

;;;;;; Killing
(defun daselt-kill-defun (&optional arg)
  "Kill the current defun, marking the active region and killing it.

ARG determines the scope of the kill."
  (interactive "p")
  (mark-defun arg)
  (kill-region (region-beginning) (region-end)))


(defun daselt-backward-kill-line (&optional arg)
  "Kill line backward."
  (declare (ftype (function (&optional integer) t)))
  (interactive "P")
  (let ((arg (or arg 0)))
    (kill-line arg)))

;;;;;; Insertion
(defun daselt-insert-and-return (str)
  "Insert STR and return to the position before insertion."
  (interactive "String: %s")
  (let ((pos (point)))
    (insert str)
    (goto-char pos)))

(defun daselt-insert-space-forward ()
  "Insert a space and return to the original position."
  (interactive)
  (daselt-insert-and-return " "))

(defun daselt-insert-newline-forward ()
  "Insert a newline and return to the original position."
  (interactive)
  (daselt-insert-and-return "\n"))

(defun daselt-mode-insert-lambda-string (&optional arg)
  "Insert string `lambda'. With ARG, insert 'λ' symbol."
  (interactive "P")
  (if arg
      (insert "λ")
    (insert "lambda")))


;;;;;; Declaring
(defun daselt-generate-declare-function ()
  "Generate a `declare-function' statement for the function at point."
  (interactive)
  ;; Check if the thing at point is a symbol
  (let ((sym (symbol-at-point)))
    (if (not (and sym (fboundp sym)))
        (message "No function at point.")
      ;; If it is a function, find where it is defined
      (let* ((function-location (find-lisp-object-file-name sym (symbol-function sym)))
             (args (help-function-arglist sym t)))
        (if (not function-location)
            (message "Cannot find function location."))
        ;; Prepare the declare-function expression
        (let ((declare-statement
               (format "(declare-function %s \"%s\" %s)"
                       sym
                       (if function-location (file-name-sans-extension
                                              (file-name-nondirectory function-location)))
                       (if args
                           (format "%s" (mapcar (lambda (arg) (if (symbolp arg) arg (car arg))) args))
                         "nil"))))
          (cl-flet ()
            (save-excursion (if (progn (goto-char (point-min))
                                       (daselt-base-search-at-line-start "\(declare-function"
                                                                         t))
                                (progn (beginning-of-line)
                                       (insert (daselt-base-append-newlines 1 declare-statement)))
                              (if (daselt-base-search-at-line-start "\(require" t)
                                  (progn (while (re-search-forward
                                                 (rx line-start
                                                     (* (or ";" " "))
                                                     "(require"))
                                           (end-of-line))
                                         (insert (daselt-base-prepend-newlines 2 declare-statement)))
                                (if (daselt-base-search-at-line-start ";;;; Preamble")
                                    (progn (end-of-line)
                                           (insert (daselt-base-surround-by-newlines
                                                    1 1 declare-statement)))
                                  (if (daselt-base-search-at-line-start ";;; Code")
                                      (progn (end-of-line)
                                             (insert (format "\n;;;; Preamble\n%s"
                                                             declare-statement))))))))))))))

(defun daselt-generate-variable-definition ()
  "Generate an unvalued `defvar' statement for the variable at point.

The produced statement will be added to the preamble of the current file."
  (interactive)
  (let ((sym (symbol-at-point)))
    (if (not sym)
        (message "No symbol under point.")
      (let ((defvar-statement (concat "(defvar " (symbol-name sym) ")")))
        (save-excursion (if (progn (goto-char (point-min))
                                   (daselt-base-search-at-line-start "(defvar"))
                            (progn (beginning-of-line)
                                   (insert (daselt-base-append-newlines 1 defvar-statement)))
                          (if (daselt-base-search-at-line-start "(declare-function")
                              (progn (while  (daselt-base-search-at-line-start "(declare-function")
                                       (end-of-line))
                                     (insert (daselt-base-prepend-newlines 2 defvar-statement)))
                            (if (daselt-base-search-at-line-start ";;;; Preamble")
                                (progn (end-of-line)
                                       (insert (daselt-base-prepend-newlines 1 defvar-statement)))
                              (if (daselt-base-search-at-line-start ";;; Code")
                                  (progn (end-of-line)
                                         (insert (format "\n;;;; Preamble\n%s"
                                                         defvar-statement))))))))))))

;;;;;; Recentering
(defun daselt-recenter-top ()
  "Recenter the screen with the current line at the top."
  (interactive)
  (recenter 1))

(defun daselt-recenter-bottom ()
  "Recenter the screen with the current line at the bottom."
  (interactive)
  (recenter -1))

;;;;;; Toggling
(defun daselt-toggle-mode-line ()
  "Toggle the visibility of the mode line."
  (interactive)
  (if (equal mode-line-format nil)
      (setq mode-line-format
            '("%e" mode-line-front-space
              (:propertize
               ("" mode-line-mule-info mode-line-client mode-line-modified
                mode-line-remote)
               display (min-width (5.0)))
              mode-line-frame-identification mode-line-buffer-identification "   "
              mode-line-position (vc-mode vc-mode) "  " mode-line-modes
              mode-line-misc-info mode-line-end-spaces))
    (setq mode-line-format nil)))

(defun daselt-toggle-variable (var)
  "Toggle VAR between true and false."
  (interactive "vToggle variable: ")
  (if (symbol-value var)
      (set var nil)
    (set var t)))


;;;;;; Search
(defun daselt-do-not-search-invisible ()
  "Set the search to ignore invisible portions of the text."
  (interactive)
  (setq search-invisible nil)
  (message "Invisible text is not searched."))

(defun daselt-search-invisible ()
  "Set the search to include invisible portions of the text."
  (interactive)
  (setq search-invisible t)
  (message "Invisible text is searched."))

(defun daselt-isearch-backward-thing-at-point ()
  "Do incremental search forward for the `thing' found near point.

Like ordinary incremental search except that the `thing' found at point is added
to the search string initially. The `thing' is defined by
`bounds-of-thing-at-point'. You can customize the variable
`isearch-forward-thing-at-point' to define a list of symbols to try to find a
`thing' at point. For example, when the list contains the symbol `region' and
the region is active, then text from the active region is added to the search
string."
  (interactive)
  (isearch-forward nil 1)
  (let ((bounds (seq-some (lambda (thing)
                            (bounds-of-thing-at-point thing))
                          isearch-forward-thing-at-point)))
    (cond
     (bounds
      (when (use-region-p)
        (deactivate-mark))
      (when (< (car bounds) (point))
	(goto-char (car bounds)))
      (isearch-yank-string
       (buffer-substring-no-properties (car bounds) (cdr bounds))))
     (t
      (setq isearch-error "No thing at point")
      (isearch-push-state)
      (isearch-update)))))

(defun daselt-isearch-backward-symbol (&optional _not-symbol no-recursive-edit)
  "Do incremental search backward for a symbol.

The prefix argument is currently unused. Like ordinary incremental search except
that your input is treated as a symbol surrounded by symbol boundary constructs
\\_< and \\_>. See the command `isearch-backward' for more information. This
command does not support character folding, and lax space matching has no effect
on it."
  (interactive "P\np")
  (isearch-mode nil nil nil (not no-recursive-edit) 'isearch-symbol-regexp))

(defun daselt-isearch-backward-word (&optional not-word no-recursive-edit)
  "Do incremental search backward for a sequence of words.

With a prefix argument, do a regular string search instead. Like ordinary
incremental search except that your input is treated as a sequence of words
without regard to how the words are separated. See the command
`isearch-backward' for more information. This command does not support character
folding, and lax space matching has no effect on it."
  (interactive "P\np")
  (isearch-mode nil nil nil (not no-recursive-edit) (null not-word)))

(defun daselt-isearch-backward-symbol-at-point (&optional arg)
  "Do incremental search backward for a symbol found near point.

Like ordinary incremental search except that the symbol found at point is added
to the search string initially as a regexp surrounded by symbol boundary
constructs \\_< and \\_>. See the command `daselt-ext-isearch-backward-symbol'
for more information. With a prefix argument, search for ARGth symbol backward
if ARG is positive, or search for ARGth symbol backward if ARG is negative."
  (interactive "P")
  (daselt-isearch-backward-symbol nil 1)
  (let ((bounds (find-tag-default-bounds))
        (count (and arg (prefix-numeric-value arg))))
    (cond
     (bounds
      (when (< (car bounds) (point))
	(goto-char (car bounds)))
      (isearch-yank-string
       (buffer-substring-no-properties (car bounds) (cdr bounds)))
      (when count
        (isearch-repeat-backward count)))
     (t
      (setq isearch-error "No symbol at point")
      (isearch-push-state)
      (isearch-update)))))

;;;;;; Replace
(defun daselt-replace-listwise (&rest strings)
  "Interactively replace strings listwise within a region or buffer.

Operates on each instance of STRINGS, mapping the nth string to the (n-1)th. For
the final string in STRINGS, if it has not appeared previously, it is removed;
otherwise, it cycles the replacements. A prefix argument reverses the mappings.

For example, with input strings A, B, C, ...: Without prefix: A -> B, B -> C,
..., Y -> Z, Z -> (removed) With prefix: A <- B, B <- C, ..., Y <- Z, Z <-
\(removed)

Special case: With A, B, A, instances of A are replaced with B, and vice versa.
The user is prompted to input the strings, which are collected into STRINGS.

This function uses a placeholder based on 'πλαχεηολδερ' to handle replacements.
This word should not occur in the text being processed. If it does, change the
placeholder.

Operates on the active region if present; otherwise, it operates on the entire
buffer.

Interactively, STRINGS are collected by prompting with a minibuffer until an
empty string is entered. The function then sequentially replaces occurrences of
each string with a unique placeholder, followed by a second pass replacing
placeholders with the mapped string values, ensuring reliable in-place text
replacement."
  (interactive (let (input inputs)
                 (prog2 (while (not (equal (setq input
                                                 (completing-read "Enter strings to cycle (enter empty string to exit): " nil))
                                           ""))
                          (push input inputs))
                     inputs)))
  (let* ((beg (if (use-region-p) (region-beginning) (point-min)))
         (end (if (use-region-p) (region-end) (point-max)))
         ;; Remove brackets if you get arguments as a list.
         (strings (if (listp (car strings)) (car strings) strings))
         ;; Reverse string if you get a prefix arg.
         (strings (if current-prefix-arg
                      (reverse strings)
                    strings)))
    (progn (cl-loop for n from 0 to (1- (length strings))
                    for oldstring = (nth n strings)
                    for placeholder = (format "πλαχεηολδερ%s" n)
                    for lengthdiff = (- (length placeholder) (length oldstring))
                    do (goto-char beg)
                    do (while (search-forward oldstring end t)
                         (replace-match placeholder case-replace t)
                         (setq end (+ end lengthdiff))))
           (cl-loop for n from 0 to (1- (1- (length strings)))
                    for newstring = (nth (1+ n) strings)
                    for placeholder = (format "πλαχεηολδερ%s" n)
                    for lengthdiff = (- (length newstring) (length placeholder))
                    do (while (search-forward placeholder end t)
                         (replace-match newstring case-replace t)
                         (setq end (+ end lengthdiff)))
                    do (goto-char beg))
           (while (re-search-forward "πλαχεηολδερ." end t)
             (replace-match "" nil t)))))

(defun daselt-exchange (string1 string2)
  "Interactively exchange STRING1 with STRING2 in buffer or active region.

Calls `daselt-replace-listwise` to perform the exchange."
  (interactive "sEnter first string to exchange: \nsEnter second string to exchange: ")
  (daselt-replace-listwise string1 string2 string1))

(defun daselt-replace-string-backward (from-string to-string &optional delimited start end region-noncontiguous-p)
  "Perform backward string replacement from FROM-STRING to TO-STRING.

DELIMITED, START, END, and REGION-NONCONTIGUOUS-P are as in `replace-string`."
  (declare (interactive-only
	    "use `search-forward' and `replace-match' instead.")
	   (interactive-args
	    (start (use-region-beginning))
	    (end (use-region-end))
	    (region-noncontiguous-p (use-region-noncontiguous-p))))
  (interactive
   (let ((common
	  (query-replace-read-args
	   (concat "Replace"
		   " backward"
		   " string"
		   (if (use-region-p) " in region" ""))
	   nil)))
     (list (nth 0 common) (nth 1 common) (nth 2 common)
	   (use-region-beginning) (use-region-end)
	   (use-region-noncontiguous-p))))
  (perform-replace from-string to-string nil nil delimited nil nil start end t region-noncontiguous-p))

(defun daselt-replace-regexp-backward (regexp to-string &optional delimited start end region-noncontiguous-p)
  "Perform backward regexp replacement from REGEXP to TO-STRING.

DELIMITED, START, END, and REGION-NONCONTIGUOUS-P are as in `replace-regexp`."
  (declare (interactive-only
	    "use `re-search-forward' and `replace-match' instead.")
	   (interactive-args
	    (start (use-region-beginning))
	    (end (use-region-end))
	    (region-noncontiguous-p (use-region-noncontiguous-p))))
  (interactive
   (let ((common
	  (query-replace-read-args
	   (concat "Replace"
		   " backward"
		   " regexp"
		   (if (use-region-p) " in region" ""))
	   t)))
     (list (nth 0 common) (nth 1 common) (nth 2 common)
	   (use-region-beginning) (use-region-end)
	   (use-region-noncontiguous-p))))
  (perform-replace regexp to-string nil t delimited nil nil start end t region-noncontiguous-p))

(defun daselt-query-replace-string-backward (from-string to-string &optional delimited start end region-noncontiguous-p)
  "Perform backward interactive query replace from FROM-STRING to TO-STRING.

DELIMITED, START, END, and REGION-NONCONTIGUOUS-P are as in
`query-replace-string`."
  (declare (interactive-only
	    "use `search-forward' and `replace-match' instead.")
	   (interactive-args
	    (start (use-region-beginning))
	    (end (use-region-end))
	    (region-noncontiguous-p (use-region-noncontiguous-p))))

  (interactive
   (let ((common
	  (query-replace-read-args
	   (concat "Replace"
		   " backward"
		   " string"
		   (if (use-region-p) " in region" ""))
	   nil)))
     (list (nth 0 common) (nth 1 common) (nth 2 common)
	   (use-region-beginning) (use-region-end)
	   (use-region-noncontiguous-p))))
  (perform-replace from-string to-string t nil delimited nil nil start end t region-noncontiguous-p))

(defun daselt-query-replace-regexp-backward (regexp to-string &optional delimited start end region-noncontiguous-p)
  "Perform backward interactive query replace from REGEXP to TO-STRING.

DELIMITED, START, END, and REGION-NONCONTIGUOUS-P are as in
`query-replace-regexp`."
  (declare (interactive-only
	    "use `re-search-forward' and `replace-match' instead.")
	   (interactive-args
	    (start (use-region-beginning))
	    (end (use-region-end))
	    (region-noncontiguous-p (use-region-noncontiguous-p))))
  (interactive
   (let ((common
	  (query-replace-read-args
	   (concat "Replace"
		   " backward"
		   " regexp"
		   (if (use-region-p) " in region" ""))
	   t)))
     (list (nth 0 common) (nth 1 common) (nth 2 common)
	   (use-region-beginning) (use-region-end)
	   (use-region-noncontiguous-p))))
  (perform-replace regexp to-string t t delimited nil nil start end t region-noncontiguous-p))

(defun daselt-replace-string-throughout-buffer (from-string to-string)
  "Replace all instances of FROM-STRING with TO-STRING throughout the buffer."
  (interactive
   (let ((common
	  (query-replace-read-args (concat "Replace string in buffer: ")
                                   nil)))
     (list (nth 0 common) (nth 1 common))))
  (save-excursion (daselt-base-goto-min)
                  (while (search-forward from-string nil t)
                    (replace-match to-string nil t))))

(defun daselt-replace-regexp-throughout-buffer (from-regexp replacement)
  "Replace all instances of FROM-REGEXP with REPLACEMENT throughout the buffer."
  (interactive
   (let ((common
	  (query-replace-read-args (concat "Replace regexp in buffer: ")
                                   nil)))
     (list (nth 0 common) (nth 1 common))))
  (save-excursion (daselt-base-goto-min)
                  (while (re-search-forward from-regexp nil t)
                    (replace-match replacement))))

(defun daselt-replace-string-throughout-directory (from-string to-string dir &optional filetest dirtest allfiles)
  "Replace FROM-STRING with TO-STRING in files in DIR.

FILETEST can be either a regexp or a function. If it is a regexp, replacement is
only done in a file if the regexp is matched in the filename. If it is a
function, that function is called with the filename as an argument and
replacement is only done if the output is non-nil.

DIRTEST is a test for whether a directory should be recursed into. It can be
either a regexp or a function and works similar to FILETEST.

If ALLFILES is t, all files and directories are considered, otherwise hidden
files and directories (starting with a period) are left out."
  (interactive "sString: \nsReplacement: \nDDirectory: ")
  (let* ((buf (current-buffer))
         (newfiletest (if filetest
                          (if (stringp filetest)
                              (lambda (fname) (string-match-p filetest fname))
                            filetest)
                        (lambda (_file) t)))
         (newdirtest (if (stringp dirtest)
                         (lambda (fname) (string-match-p dirtest fname))
                       dirtest)))
    (save-excursion
      (daselt-dirs-recurse-through-directory
       dir
       `(((lambda (fname) (set-buffer (find-file-noselect fname))
            (daselt-replace-string-throughout-buffer ,from-string ,to-string))
          . (lambda (idx flist)
              (let ((file (nth idx flist)))
                (funcall ,newfiletest file)))))
       newdirtest
       nil
       allfiles)
      (set-buffer buf))))

(defun daselt-replace-regexp-throughout-directory (regexp replacement dir &optional filetest dirtest allfiles)
  "Replace REGEXP with REPLACEMENT in files in DIR.

FILETEST can be either a regexp or a function. If it is a regexp, replacement is
only done in a file if the regexp is matched in the filename. If it is a
function, that function is called with the filename as an argument and
replacement is only done if the output is non-nil.

DIRTEST is a test for whether a directory should be recursed into. It can be
either a regexp or a function and works similar to FILETEST.

If ALLFILES is t, all files and directories are considered, otherwise hidden
files and directories (starting with a period) are left out."
  (interactive "sString: \nsReplacement: \nDDirectory: ")
  (let* ((buf (current-buffer))
         (newfiletest (if filetest
                          (if (stringp filetest)
                              (lambda (fname) (if (string-match-p filetest fname) t))
                            filetest)
                        (lambda (_file) t)))
         (newdirtest (if (stringp dirtest)
                         (lambda (fname) (if (string-match-p dirtest fname) t))
                       dirtest)))
    (save-excursion
      (daselt-dirs-recurse-through-directory
       dir
       `(((lambda (fname) (set-buffer (find-file-noselect fname))
            (daselt-replace-regexp-throughout-buffer ,regexp ,replacement))
          . (lambda (idx flist)
              (let ((file (nth idx flist)))
                (funcall ,newfiletest file)))))
       newdirtest
       nil
       allfiles)
      (set-buffer buf))))

;;;;;; Open Emacs
(defun daselt-open-file-in-new-emacs (&optional filename)
  "Open FILENAME in a new Emacs instance with `--debug-init` and `--no-desktop`.

Defaults to the current buffer's file if FILENAME isn't specified."
  (interactive)
  (let ((filename (if filename filename
                    (daselt-base--escape-chars-in-str
                     (if (buffer-file-name)
                         (buffer-file-name)
                       (error "Buffer not visiting a file"))
                     (list (rx-to-string `(group " ")))))))
    (shell-command (format "emacs --no-desktop --debug-init %s &" filename))))


(defun daselt-open-file-in-new-emacs-no-init (&optional filename)
  "Open FILENAME in a new Emacs instance without loading the init file.

Defaults to the current buffer's file if FILENAME isn't specified."
  (interactive)
  (let ((filename (if filename filename (daselt-base--escape-chars-in-str
                                         (buffer-file-name)
                                         (list (rx-to-string `(group " ")))))))
    (shell-command (format "emacs -q %s &" filename))))


;;;;;; Keys
(defun daselt-minor-mode-key-binding (key)
  "Retrieve the list of minor mode keybindings for KEY.

Ignore the override map."
  (interactive "sKey: ")
  (let ((active-maps nil))
    (mapc (lambda (x)
	    (when (and (symbolp (car x)) (symbol-value (car x)))
	      (add-to-list 'active-maps  (lookup-key (cdr x) (kbd key)))))
	  minor-mode-map-alist )
    (make-composed-keymap active-maps)))

;;;;;; Macros to create further `daselt-mode' commands
(daselt-base-def-by-forms
 ((let ((str-is-top (string= str "top")))
    `(defun ,(intern (concat "daselt-move-to-" str)) ()
       "Move to the ,str of the current window."
       (interactive)
       (let ((this-scroll-margin (min (max 0 scroll-margin) (truncate (/ (window-body-height) 4.0)))))
         (move-to-window-line ,(if str-is-top
                                   'this-scroll-margin
                                 '(- -1 this-scroll-margin)))))))
 (str . ("top" "bottom")))

(daselt-base-def-by-forms-by-variables
 (`(defun ,(intern (concat "daselt-backward-"
                           (replace-regexp-in-string
                            "daselt-" "" (symbol-name cmd))))
       (&optional arg)
     ,(daselt-base-fill-string-like-docstring
       (format "A version of %s with a negative argument so it acts backwards.
Generated automatically using `daselt-backward-command-list'." cmd))
     (interactive "p")
     (,cmd (- arg))))
 (cmd . daselt-backward-command-list))

(daselt-base-def-by-forms-by-variables
 (`(defun ,(intern (concat "daselt-in-new-buffer-"
                           (replace-regexp-in-string
                            "daselt-" "" (symbol-name cmd))))
       (&optional arg)
     ,(format "A version of %s with an argument so it uses a new buffer.
Generated automatically using `daselt-new-buffer-command-list'." cmd)
     (interactive "p")
     (,cmd (- arg))))
 (cmd . daselt-new-buffer-command-list))

;; Create subsentence-analogs of sentence-commands in daselt-subsentence-command-list.
(daselt-base-def-by-forms-by-variables
 ((let ((nullary (= 0 (cdr (func-arity cmd)))))
    `(defun ,(intern (concat "daselt-"
                             (replace-regexp-in-string
                              "daselt-" ""
                              (replace-regexp-in-string
                               "sentence" "subsentence" (symbol-name cmd)))))
         ,(if nullary '() '(arg))
       ,(daselt-base-fill-string-like-docstring
         (format "Execute %s with subsentence-signs as delimiters." (symbol-name cmd)))
       (interactive "p")
       (let ((sentence-end-base "[.?!…‽;:,][]\"'”’)}»›]*"))
         ,(remq nil `(,cmd ,(unless nullary 'arg)))))))
 (cmd . daselt-subsentence-command-list))

;;;; Provide
(provide 'daselt-ext)
;;; daselt-ext.del ends here
