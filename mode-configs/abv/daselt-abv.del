;;; daselt-abv.del --- Daselt's abv module  -*- lexical-binding: t; -*-

;; Copyright (C) 2025  Alexander Prähauser

;; Author: Alexander Prähauser <ahprae@protonmail.com>
;; Keywords: tools, abbrev, convenience

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; Affix placement and visualization utilities for Daselt.
;;
;; This module now defines a default `abv-layout' instance instead of exposing
;; many defcustom options. Interactive frontends delegate to generic methods.

;;; Code:

(require 'daselt-bind)
(require 'daselt-dirs)
(require 'cl-lib)
(require 'abv-data)
(require 'abv-corpus)
(require 'abv-layouts)
(require 'dash) ;; for -filter

;;;; Object instance (replaces many options)

(defvar daselt-abv--default-layout
  (let* ((single-symbol-placevals
          (let ((print-level nil) (print-length nil))
            (cl-remove-if
             (lambda (cons)
               (or (< 1 (length (cdr cons)))
                   (let* ((char (string-to-char (cdr cons)))
                          (syx (with-syntax-table text-mode-syntax-table (char-syntax char))))
                     (cl-member syx '(?\  ?\- ?\") :test #'=))))
             (daselt-base-flatten-n-times (cdr (daselt-coords-coordinatize-layout
                                                (symbol-value daselt-dfk-layout))) 2))))
         (prefix-classes '(?w ?_ ?. ?\) ?\> ?\!))
         (suffix-classes '(?\w ?\_ ?\( ?\< ?\!))
         (infix-classes  '(?w ?_ ?. ?\( ?\< ?\) ?\!))
         (standalone-classes '(?w ?_ ?. ?\( ?\< ?\) ?\!))
         (root-classes '(?w ?_))
         (layer-pairs '((1 . 2) (4 . 3) (5 . 6) (8 . 7)))
         (special-placevals '((1 -1 -3) (1 -1 3) (4 1 0) (5 1 0)))
         (special-non-prefix-placevals nil)
         (special-non-suffix-placevals nil)
         (added-syntax-classes '(?_))
         (save-file (let ((dir (ignore-errors (and (boundp 'daselt-mode-pkg-configs-directory)
                                                   (file-name-as-directory daselt-mode-pkg-configs-directory)))))
                      (expand-file-name (concat (or dir (file-name-as-directory user-emacs-directory))
                                                "abv/save.el"))))
         ;; Derived placevals helpers
         (placevals-from-classes
          (lambda (classes)
            (let ((print-level nil) (print-length nil))
              (-filter
               (lambda (cons)
                 (and (= 1 (length (cdr cons)))
                      (let* ((char (string-to-char (cdr cons)))
                             (syx (with-syntax-table org-mode-syntax-table (char-syntax char))))
                        (cl-member syx classes :test #'=))))
               (daselt-base-flatten-n-times
                (cdr (daselt-coords-coordinatize-layout
                      (symbol-value daselt-dfk-layout))) 2)))))
         (filter-to-paired
          (lambda (placevals)
            (let* ((pairs layer-pairs))
              (cl-remove-if-not
               (lambda (pv)
                 (pcase-let* ((`(,L ,r ,c) (car pv))
                              (upper (cdr (assoc L pairs))))
                   (alist-get (list upper r c) placevals nil nil #'equal)))
               placevals))))
         ;; Derived placevals
         (valid-prefix-placevals
          (cl-remove-if (lambda (cns)
                          (cl-member (car cns)
                                     (cl-union special-placevals special-non-prefix-placevals)
                                     :test #'equal))
                        (funcall placevals-from-classes prefix-classes)))
         (valid-lower-paired-prefix-placevals
          (cl-intersection valid-prefix-placevals
                           (funcall filter-to-paired (funcall placevals-from-classes prefix-classes))
                           :test #'equal))
         (valid-suffix-placevals
          (cl-remove-if (lambda (cns)
                          (cl-member (car cns)
                                     (cl-union special-placevals special-non-suffix-placevals)
                                     :test #'equal))
                        (funcall placevals-from-classes suffix-classes)))
         (valid-lower-paired-suffix-placevals
          (cl-intersection valid-suffix-placevals
                           (funcall filter-to-paired (funcall placevals-from-classes suffix-classes))
                           :test #'equal)))
    (make-instance 'abv-layout
                   :name "daselt-default"
                   :non-constituents '(?- ?_ ?: ?. ?, ?! ?? ?' ?`)
                   :single-symbol-placevals single-symbol-placevals
                   :prefix-classes prefix-classes
                   :suffix-classes suffix-classes
                   :infix-classes infix-classes
                   :standalone-classes standalone-classes
                   :root-classes root-classes
                   :layer-pairs layer-pairs
                   :special-placevals special-placevals
                   :special-non-prefix-placevals special-non-prefix-placevals
                   :special-non-suffix-placevals special-non-suffix-placevals
                   :added-syntax-classes added-syntax-classes
                   :save-file save-file
                   :valid-prefix-placevals valid-prefix-placevals
                   :valid-lower-paired-prefix-placevals valid-lower-paired-prefix-placevals
                   :valid-suffix-placevals valid-suffix-placevals
                   :valid-lower-paired-suffix-placevals valid-lower-paired-suffix-placevals))
  "Default abv-layout object constructed directly (options replaced).")

;;;; Helper functions for assignment/visualization (reused by methods)

(defun daselt-abv--alist->hash (alist &optional key-fn)
  (let ((ht (make-hash-table :test 'equal)))
    (dolist (kv alist ht)
      (let ((k (if key-fn (funcall key-fn (car kv)) (car kv)))
            (v (cdr kv)))
        (puthash k v ht)))))

(defun daselt-abv--placevals->coord-hash (placevals)
  (let ((ht (make-hash-table :test 'equal)))
    (dolist (pv placevals ht)
      (puthash (car pv) (cdr pv) ht))))

(defun daselt-abv--keys (hash)
  (let (ks) (maphash (lambda (k _v) (push k ks)) hash) ks))

(defun daselt-abv--letter-p (s)
  (and (stringp s) (= (length s) 1)
       (let ((c (aref s 0)))
         (or (and (<= ?a c) (<= c ?z)) (and (<= ?A c) (<= c ?Z))))))

(defun daselt-abv--down (s) (if (and (stringp s) (= (length s) 1)) (downcase s) s))

(defun daselt-abv--erg-score (coord)
  (pcase-let ((`(,L ,row ,col) coord))
    (let* ((abscol (abs col))
           (row-pen (if (= row 0) 0.0 0.6))
           (col-pen (pcase abscol (1 1.0) (2 1.2) (3 1.5) (4 2.0) (5 3.0) (6 4.0) (_ 5.0)))
           (layer-pen (pcase L (1 0.0) ((or 2 4) 0.2) ((or 6 5) 0.4) ((or 7 3) 0.6) (8 0.8) (_ 1.0))))
      (+ row-pen col-pen layer-pen))))

(defun daselt-abv--coord-layers-in-order (complementp)
  (if complementp '(2 1 4 6 5 7 3 8) '(1 2 4 6 5 7 3 8)))

(defun daselt-abv--neighbors (r c layers)
  (let ((coords '()))
    (dolist (L layers) (push (list L r c) coords))
    (dolist (dr '(-1 1)) (dolist (L layers) (push (list L (+ r dr) c) coords)))
    (dolist (dc '(-1 1)) (dolist (L layers) (push (list L r (+ c dc)) coords)))
    (nreverse coords)))

(defun daselt-abv--collect-letter-bases (placevals)
  (let ((per-letter (make-hash-table :test 'equal)))
    (dolist (pv placevals)
      (let* ((coord (car pv)) (binding (daselt-abv--down (cdr pv))))
        (when (daselt-abv--letter-p binding)
          (push coord (gethash binding per-letter)))))
    (let ((out (make-hash-table :test 'equal)))
      (maphash
       (lambda (letter coords)
         (let* ((on-l1 (cl-find-if (lambda (cc) (= (car cc) 1)) coords))
                (best (or on-l1 (car (cl-sort (copy-sequence coords)
                                              (lambda (a b)
                                                (< (daselt-abv--erg-score a)
                                                   (daselt-abv--erg-score b))))))))
           (puthash letter best out)))
       per-letter)
      out)))

(defun daselt-abv--affix-letters (affix)
  (let ((seen (make-hash-table :test 'equal)) (out '()))
    (dotimes (i (length affix))
      (let* ((ch (aref affix i)) (s (downcase (string ch))))
        (when (and (daselt-abv--letter-p s) (not (gethash s seen)))
          (puthash s t seen) (push s out))))
    (nreverse out)))

(defun daselt-abv--letter-rarity (letter preferred-hash)
  (let ((n 0))
    (maphash (lambda (_coord binding)
               (when (and (stringp binding) (string= (daselt-abv--down binding) letter))
                 (setq n (1+ n))))
             preferred-hash)
    n))

(defun daselt-abv--free-candidates (preferred-hash counts-hash)
  (cl-loop for coord in (daselt-abv--keys preferred-hash)
           unless (> (gethash coord counts-hash 0) 0)
           collect coord))

(defun daselt-abv--choose-fallback (preferred-hash counts-hash)
  (let ((coords (daselt-abv--keys preferred-hash)))
    (car (cl-sort (copy-sequence coords)
                  (lambda (a b)
                    (let* ((ca (gethash a counts-hash 0)) (cb (gethash b counts-hash 0)))
                      (if (/= ca cb) (< ca cb)
                        (< (daselt-abv--erg-score a) (daselt-abv--erg-score b)))))))))

(defun daselt-abv--assign-one (affix preferred-hash counts-hash letter-base complementp)
  (let* ((letters (daselt-abv--affix-letters affix))
         (letters-sorted (cl-stable-sort (copy-sequence letters) #'<
                                         :key (lambda (L)
                                                (daselt-abv--letter-rarity L preferred-hash))))
         (layers (daselt-abv--coord-layers-in-order complementp))
         (chosen-coord nil))
    (cl-loop for L in letters-sorted
             for base = (gethash L letter-base)
             when base do
             (pcase-let ((`(,_ ,r ,c) base))
               (let ((cands (daselt-abv--neighbors r c layers)))
                 (cl-loop for coord in cands
                          for binding = (gethash coord preferred-hash)
                          when (and binding (<= (gethash coord counts-hash 0) 0))
                          do (setq chosen-coord coord) (cl-return))))
             when chosen-coord do (cl-return))
    (unless chosen-coord
      (let ((free (daselt-abv--free-candidates preferred-hash counts-hash)))
        (setq chosen-coord (if free (car (cl-sort free #'< :key #'daselt-abv--erg-score))
                             (daselt-abv--choose-fallback preferred-hash counts-hash)))))
    (cl-incf (gethash chosen-coord counts-hash 0))
    chosen-coord))

(defun daselt-abv--complement-hash (universe-hash subset-hash)
  (let ((ht (make-hash-table :test 'equal)))
    (maphash (lambda (coord binding)
               (unless (gethash coord subset-hash) (puthash coord binding ht)))
             universe-hash)
    ht))

(defun daselt-abv--sorted-affixes-by-frequency (affixes freq-alist)
  (let* ((freq (daselt-abv--alist->hash freq-alist))
         (pair (mapcar (lambda (a) (cons a (or (gethash a freq) 0))) affixes)))
    (mapcar #'car
            (cl-sort pair (lambda (a b)
                            (let ((fa (cdr a)) (fb (cdr b)))
                              (if (/= fa fb) (> fa fb)
                                (let ((la (length (car a))) (lb (length (car b))))
                                  (if (/= la lb) (< la lb) (string< (car a) (car b)))))))))))

;;;; Methods bridge to abv-layout generics

(cl-defmethod abv-layout-assign-affixes ((_layout abv-layout) affixes frequencies table-id)
  (unless (and (listp affixes) (listp frequencies) (symbolp table-id))
    (user-error "Invalid inputs: expected (list list symbol)"))
  (let* ((freqs (daselt-abv--normalize-frequencies frequencies))
         (table-sym (pcase table-id ('prefix 'daselt-abv-prefix-table)
                                  ('suffix 'daselt-abv-suffix-table)
                                  ('infix  'daselt-abv-infix-table)
                                  ('root   'daselt-abv-root-table)
                                  (_ (user-error "Unknown table-id %S" table-id))))
         (table (daselt-abv--ensure-hash-table table-sym))
         (used-coords (make-hash-table :test 'equal))
         (counts (make-hash-table :test 'equal)))
    (maphash (lambda (_a c) (puthash c t used-coords) (cl-incf (gethash c counts 0))) table)
    (pcase table-id
      ('prefix
       (let* ((univ-h (daselt-abv--placevals->coord-hash (oref daselt-abv--default-layout valid-prefix-placevals)))
              (paired-h (daselt-abv--placevals->coord-hash (oref daselt-abv--default-layout valid-lower-paired-prefix-placevals)))
              (compl-h (daselt-abv--complement-hash univ-h paired-h))
              (sorted (daselt-abv--sorted-affixes-by-frequency affixes freqs))
              (letter-base (daselt-abv--collect-letter-bases
                            (append (oref daselt-abv--default-layout valid-prefix-placevals)
                                    (oref daselt-abv--default-layout valid-suffix-placevals)))))
         (dolist (a sorted)
           (unless (gethash a table)
             (let* ((coord (daselt-abv--assign-one a paired-h counts letter-base nil)))
               (when (or (null coord) (gethash coord used-coords))
                 (setq coord (daselt-abv--assign-one a compl-h counts letter-base t)))
               (when coord (puthash coord t used-coords) (puthash a coord table)))))
         table))
      ('suffix
       (let* ((univ-h (daselt-abv--placevals->coord-hash (oref daselt-abv--default-layout valid-suffix-placevals)))
              (paired-h (daselt-abv--placevals->coord-hash (oref daselt-abv--default-layout valid-lower-paired-suffix-placevals)))
              (compl-h (daselt-abv--complement-hash univ-h paired-h))
              (sorted (daselt-abv--sorted-affixes-by-frequency affixes freqs))
              (letter-base (daselt-abv--collect-letter-bases
                            (append (oref daselt-abv--default-layout valid-prefix-placevals)
                                    (oref daselt-abv--default-layout valid-suffix-placevals)))))
         (dolist (a sorted)
           (unless (gethash a table)
             (let* ((coord (daselt-abv--assign-one a paired-h counts letter-base nil)))
               (when (or (null coord) (gethash coord used-coords))
                 (setq coord (daselt-abv--assign-one a compl-h counts letter-base t)))
               (when coord (puthash coord t used-coords) (puthash a coord table)))))
         table))
      (_ table))))

(cl-defmethod abv-layout-visualize-layer ((_layout abv-layout) table-id laycoord)
  (let* ((table-sym (pcase table-id ('prefix 'daselt-abv-prefix-table)
                                   ('suffix 'daselt-abv-suffix-table)
                                   ('infix  'daselt-abv-infix-table)
                                   ('root   'daselt-abv-root-table)
                                   (_ (user-error "Unknown table-id %S" table-id)))))
    (when (and (symbolp table-sym) (boundp table-sym) (hash-table-p (symbol-value table-sym)))
      (unless (and (boundp (daselt-abv--table->bindlist-var table-sym))
                   (daselt-bind-bindlist-p (symbol-value (daselt-abv--table->bindlist-var table-sym))))
        (daselt-abv-table->bindlist table-sym))
      (let* ((blist (symbol-value (daselt-abv--table->bindlist-var table-sym)))
             (placevals (daselt-coords-placevals-matching-indexed-rx blist 0 laycoord))
             (drawer (if (called-interactively-p 'any)
                         #'daselt-coords-draw-placevals-in-temp-buffer
                       #'daselt-coords-draw-placevals)))
        (funcall drawer placevals nil nil current-prefix-arg)))))

(cl-defmethod abv-layout-lookup-affix ((_layout abv-layout) table-id query)
  (let* ((table-sym (pcase table-id ('prefix 'daselt-abv-prefix-table)
                                   ('suffix 'daselt-abv-suffix-table)
                                   ('infix  'daselt-abv-infix-table)
                                   ('root   'daselt-abv-root-table)
                                   (_ (user-error "Unknown table-id %S" table-id))))
         (tbl (and (boundp table-sym) (symbol-value table-sym)))
         (hit (and (hash-table-p tbl) (gethash query tbl))))
    (if hit
        (prog1 hit (message "%s => %S" query hit))
      (message "Not found in %S" table-id)
      nil)))

(cl-defmethod abv-layout-lookup-root ((_layout abv-layout) root)
  (let ((tbl (oref daselt-abv--default-layout root-table)))
    (and (hash-table-p tbl) (gethash root tbl))))

;;;; Frontends

;;;###autoload
(defun daselt-abv-assign-affixes (affixes frequencies table-id)
  "Assign AFFIXES with FREQUENCIES into TABLE-ID (one of
prefix/suffix/infix/root)."
  (interactive
   (let* ((table-id (intern (completing-read "Table: " '("prefix" "suffix" "infix" "root") nil t nil nil "prefix")))
          (affs (pcase table-id ('prefix abv-prefixes) ('suffix abv-suffixes) ('infix abv-infixes) ('root abv-roots)))
          (freqs (mapcar (lambda (a) (cons a 1)) affs)))
     (list affs freqs table-id)))
  (abv-layout-assign-affixes daselt-abv--default-layout affixes frequencies table-id))

;;;###autoload
(defun daselt-abv-draw-table-layer (table-id laycoord)
  "Visualize one layer of TABLE-ID by drawing its placevals directly."
  (interactive
   (let* ((table-id (intern (completing-read "Table: " '("prefix" "suffix" "infix" "root") nil t nil nil "prefix")))
          (lay (read (read-from-minibuffer "Layer coordinate: "))))
     (list table-id (number-to-string lay))))
  (abv-layout-visualize-layer daselt-abv--default-layout table-id laycoord))

;;;###autoload
(defun daselt-abv-look-up ()
  "Look up an affix/root in a chosen table and display coordinates if found."
  (interactive)
  (let* ((table-id (intern (completing-read "Table: " '("prefix" "suffix" "infix" "root") nil t)))
         (query (read-string (format "Query for %s: " table-id))))
    (abv-layout-lookup-affix daselt-abv--default-layout table-id query)))

(provide 'daselt-abv)
;;; daselt-abv.del ends here
